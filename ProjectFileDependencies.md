The Project File Dependencies dealt with taking in a project file and outputting the order of how tasks should be done. The project file begins with a number ranging from 1 through 100 that indicates the number of tasks or in our case, vertices. It is then followed by another number detailing the number of rules to follow in the file or another way of interpreting it is the number of lines left in the file. The rest of the lines in the file are each rules that express the dependencies of a vertex. Each line is a rule that begins with a vertex number, the second number to be read details the number of dependencies the vertex has which also gives how many numbers are in the rest of the line.

In order to come up with a solution we decided to treat each vertex as a node that stores its value, its parents and its children. This was done by creating a Class named Node that stores the value of the vertex as an int with its parents and children in an array respectively. The Node class has two methods to append a child and a parent. The method pfd\_solve takes care of creating the graph and formatting the correct output. It begins by reading in the first line from the project file and stores both numbers in an array labeled a. The element in index 0 of the array is used to create a separate array, list\_of\_nodes, of size equal to the element's value. List\_of\_nodes stores a Node in each index of the array with a value equal to the index. The element in index 1 of array a is used to determine the number of rules which is used to define the number of times pfd\_read will be called going forward.

The method pfd\_read takes in a reader r and an array a. The line is read and stored as a string. The array is cleared to remove any unwanted elements which is then used to store each number of the given line. This method is called in a for loop with a given range found earlier by the original array a. After reading the first line, the first number that pfd\_read stored is used as the index to find the Node in the array list\_of\_nodes with that same value, that Node is tracked to assign it its dependencies. An inner loop then goes through the rest of the numbers that pfd\_read stored and treats them as an index of the array list\_of\_nodes to collect the Nodes that are dependencies of the tracked Node an assigns them as a parent of the tracked Node, while also assigning the tracked Node as a child of each collected Node. This creates the graph of the project file as each Node now has a pointer to its parent and/or child.

The pfd\_solve method continues with a while loop that goes through the list\_of\_nodes array to create an acceptable output. This is done by going through each Node in the array and checking if it doesn't have a parent. If the given Node does not have a parent then it is removed from the array and its value is stored in a container. This container will take in each value without the need to sort since list\_of\_nodes is already sorted by the value of the vertex from least to greatest thus the Nodes that are being removed will always be removed from least to greatest. Once a Nodes is set to be removed, an inner loop looks at its children array and finds those Nodes on the list\_of\_nodes and removes the Node that is set to be removed from their parent array. This makes it that once the outer loop goes through another iteration there will be more Nodes without parents to be stored into the container. When a Node is removed from the list\_of\_nodes it is replaced with a Boolean False so the method knows to skip that index in the array. A break is set to look through the array from the beginning again to see if any Node with a value less than the Node removed has just had all its parents removed, which will then be added to the container. The loop stops until the size of the container is equal to the amount of Nodes in the list\_of\_nodes array.

The elements in the container are then concatenated into a string to be print it out by the method pfd\_write with the correct formatted output.
